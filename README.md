# DroneSimulation3_arp
The third Advanced and Robotics Programming assignament:  is a drone simulator implemented totally in c language and controllable in forces, the window is created using the *ncurses* library, in the environment random targets and obstacles spawn communicating to the server through sockets, the obstacles create a repulsive force, the *SCORE* is a funtion of how many targets and obstacles are encountered by the drone. The drone is controlled by key inputs that change the total force applied to the drone.

## Description
The program is composed by eight different processes that cooperate in real time and share informations.

The communication between the `server` and `target` and between the `server` and the `obstacles` is implemented using socket; the communication between the `server`, the `drone` and the `keyboard` is implemented using pipes and shared memory.


The final result gives to the user the possibility to move a drone in a free environment where the friction force, the forces intruduced to control it and the obstacles' repulsive forces are acting.
Furthermore the drone is unable to go out the screen.

These are the key to control the robot, however the `master` process visualises them befor starting the application:
```
UP 'e'
UP_LEFT 'w'
UP_RIGHT 'r'
RIGHT 'f'
0 FORCES 'd'
LEFT 's'
DOWN 'c'
DOWN_LEFT 'x'
DOWN_RIGHT 'v'
QUIT 'q'
```

## Architecture
![Slide1](https://github.com/user-attachments/assets/3e290ee5-54ef-4db2-9330-0a696b99898f)

`Master` -> the process that fork() and execvp() the `server`, `keyboard`, `drone`, `target` and `obstacle` process; it passes all the necessary pipes to the processes

`Keyboard` -> the process that takes the input from the user, it upadates the current force acting on the drone and it passes it through pipes to the `drone` process; if the drone is too close to an obstacle the process recieves a signal by the `server` process and collects the new values of the force (with the repulsive force) and then it passes them as usual

`Drone` -> the process that effectivily controls the drone motion, it takes through pipes from the `keyboard` process the actual force acting on the drone, from the `server` process the maximum of the coordinates that the drone can reach; it calculates the acceleration, the velocity and the position of the drone, it updates the shared memory and gives back to the `server` process the new position

`Obstacle` -> the process that reads from the `data.txt` file the number of obstacles to create and randomly creates them checking if they are feasible (two point can't be coincidend), it communicates through the `sockserver` with the `server`; after a certain amount of time it creates and sends to the server the new set of obstacles

`Target` -> the process that reads from the `data.txt` file the number of targets to create and randomly creates them checking if they are feasible (two point can't be coincidend), it communicates through the `sockserver` with the `server`; after that the drone as reached all the targets if spawns another set

`Watchdog` -> the process that verifies the correct functioning of the others, in that case it checks only on `drone`, `server` and `keyboard` process; it sends signals to the processes that it has to controll and checks for the answers, if a process fail after a certain amount of time it closes the application

`Server` -> the main process of the application; it connects all the other processes through pipes or shared memory or socket; it collects the information from the shared memory prints and updates them; it collects from the `drone` process the actual position of the drone through pipes and checks if the drone is too close to an obstacle, if it is it calculates the new force acting on the drone ,including the repulsive force generated by the obstacle, and gives back to the `keyboard` a signal and the new value of the forces; it fork() and execvp() the `sockserver` process, one for the `obstacle` and one for the `target`, collects the coordinates and checks if there are coincident points if it is it doesn't print the that ones. All those information are then printed in the window that is implemented with the *ncurses* library

`Sockserver` -> the server's child, it implements the socket communication and it has to be executed one for each client

## Overview

https://github.com/user-attachments/assets/9db72fb4-bd4e-4d7d-b862-2bfc7726616b

## Installation
To properly install the application assure you to have installe *konsole* and *ncurses* on your computer
```
$ sudo apt install konsole
$ sudo apt install libncurses-dev
```

then clone the repository on your pc
```
$ git clone https://github.com/tommasodeangeli97/DroneSimulation3_arp.git
```

by the *konsole* terminal go inside the folder
```
$ cd DroneSimulation3_arp
```

make executable the compiler
```
$ chmod +x compile.sh
```

on the server computer take the IP address
```
$ hostname -I
```

change in the `master` process the ipadrress variable and choose a port
```
int portserv = 8080;
int portT_O = 8080;
...
char ipAdrress[20] = "NOT_PUT_YET";
```

now run the compiler and then start the application
```
$ ./compile.sh
$ ./master
```

### important note
1. remenber to delet the `pidlog.log` file every time before start the application in order to have only the actual pids of the processes

2. when the parameters for the socket connection are incorrectly set, the program will not close, becouse it will wait the socket connection. To close it the only way is to interrupt the processes with ctrl+c and close the terminal window. Now (after the change of the connection setting) is possible to re-run the code.

## Possibles implementation
1. the velocity of the start of the application could be improved using the select() function or implementing the comunication phase of the processes

2. The drone could be further impruved to make it capable to rotate on itself

3. Even if it is not possible in reality could be implemented a instant block of the robot, a key to stops the robot regardless of the forces applied and the velocity accumulated

4. For the user point of view a special window can be impleted to avoid the closure of the application if the 'q' button is accidentally pressed

5. the score value can take in account more then only the targets and the obstacles incountered by the drone

6. also the keyboard could be implemented using the socket server and client to make only the keyboard and the map seeble user side

## Author and contact
Author: Tommaso De Angeli (https://github.com/tommasodeangeli97)

contact: tommaso.deangeli.97@gmail.com
