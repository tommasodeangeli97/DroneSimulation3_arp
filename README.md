# DroneSimulation3_arp
The third Advanced and Robotics Programming assignament:  is a drone simulator implemented totally in c language and controllable in forces, the window is created using the *ncurses* library, in the environment random targets and obstacles spawn communicating to the server through sockets, the obstacles create a repulsive force, the *SCORE* is a funtion of how many targets and obstacles are encountered by the drone. The drone is controlled by key inputs that change the total force applied to the drone.

## Description
The program is composed by eight different processes that cooperate in real time and share informations.

The communication between the `server` and `target` and between the `server` and the `obstacles` is implemented using socket; the communication between the `server`, the `drone` and the `keyboard` is implemented using pipes and shared memory.


The final result gives to the user the possibility to move a drone in a free environment where the friction force, the forces intruduced to control it and the obstacles' repulsive forces are acting.
Furthermore the drone is unable to go out the screen.

These are the key to control the robot, however the `master` process visualises them befor starting the application:
```
UP 'e'
UP_LEFT 'w'
UP_RIGHT 'r'
RIGHT 'f'
0 FORCES 'd'
LEFT 's'
DOWN 'c'
DOWN_LEFT 'x'
DOWN_RIGHT 'v'
QUIT 'q'
```

## Architecture
![Slide1](https://github.com/user-attachments/assets/3e290ee5-54ef-4db2-9330-0a696b99898f)

`Master` -> the process that fork() and execvp() the `server`, `keyboard`, `drone`, `target` and `obstacle` process; it passes all the necessary pipes to the processes

`Keyboard` -> the process that takes the input from the user, it upadates the current force acting on the drone and it passes it through pipes to the `drone` process; if the drone is too close to an obstacle the process recieves a signal by the `server` process and collects the new values of the force (with the repulsive force) and then it passes them as usual

`Drone` -> the process that effectivily controls the drone motion, it takes through pipes from the `keyboard` process the actual force acting on the drone, from the `server` process the maximum of the coordinates that the drone can reach; it calculates the acceleration, the velocity and the position of the drone, it updates the shared memory and gives back to the `server` process the new position

`Obstacle` -> the process that reads from the `data.txt` file the number of obstacles to create and randomly creates them checking if they are feasible (two point can't be coincidend), it communicates through the `sockserver` with the `server`; after a certain amount of time it creates and sends to the server the new set of obstacles

`Target` -> the process that reads from the `data.txt` file the number of targets to create and randomly creates them checking if they are feasible (two point can't be coincidend), it communicates through the `sockserver` with the `server`; after that the drone as reached all the targets if spawns another set

`Watchdog` -> the process that verifies the correct functioning of the others, in that case it checks only on `drone`, `server` and `keyboard` process; it sends signals to the processes that it has to controll and checks for the answers, if a process fail after a certain amount of time it closes the application

`Server` -> the main process of the application; it connects all the other processes through pipes or shared memory or socket; it collects the information from the shared memory prints and updates them; it collects from the `drone` process the actual position of the drone through pipes and checks if the drone is too close to an obstacle, if it is it calculates the new force acting on the drone ,including the repulsive force generated by the obstacle, and gives back to the `keyboard` a signal and the new value of the forces; it fork() and execvp() the `sockserver` process, one for the `obstacle` and one for the `target`, collects the coordinates and checks if there are coincident points if it is it doesn't print the that ones. All those information are then printed in the window that is implemented with the *ncurses* library

`Sockserver` -> the server's child, it implements the socket communication and it has to be executed one for each client

## Installation
To properly install the application assure you to have installe *konsole* and *ncurses* on your computer
```
$ sudo apt install konsole
$ sudo apt install libncurses-dev
```

then clone the repository on your pc
```
$ git clone https://github.com/tommasodeangeli97/DroneSimulation3_arp.git
```

by the *konsole* terminal go inside the folder
```
$ cd DroneSimulation3_arp
```

make executable the compiler
```
$ chmod +x compile.sh
```

on the server computer take the IP address
```
$ hostname -I
```

change in the `master` process the ipadrress variable and choose a port
```

```

now run the compiler and then start the application
```
$ ./compile.sh
$ ./master
```

### important note
remenber to delet the `pidlog.log` file every time before start the application in order to have only the actual pids of the processes

